---
layout: post
title:  "21.String中intern方法的理解"
date: 2019-01-04

description: "String中intern方法的理解"

tag: Java基础
---   
### 0x00 概述
今天在微信公众号上刷到一篇文章[JVM如何从入门到放弃的？](https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484287&idx=1&sn=89b9af9c1fe60ec30bf15ced34abbcce&scene=19#wechat_redirect "JVM如何从入门到放弃的？")，
看到博主对String.intern方法以及String的常量池的分析。一时间懵逼了。所以自己花点时间理了下思路。于是把自己所理解的intern用小本本记录下来，以便以后观看。如有错误之处。望大家能够指正。

### 0x01 常量池
1. 在JDK1.7后，我们的常量池从永久代移到了堆中。
2. 常量池存储的是：
	1. 字面量。即文本字符串等。使用双引号声明出来的String对象(如:String str = "123",其中"123"就会存在常量池中)，都会存在这里。
	2. 符号引用。包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。

### 0x02 String.intern()
1. String.intern()方法的作用：
	- 如果在常量池中，存在当前的字符串，那么直接返回常量池中对当前字符串的引用。
	- 如果常量池中，没有当前字符串，那么会将当前字符串引用保存到常量池中后，在返回该字符串的引用。
2. JDK1.6和1.7中String.intern()方法的不同之处：
	- 在JDK1.6中，常量池是存放在永久代，而new出来的对象是放在堆中。执行intern方法后，如果常量池中没有，则会创建一个字符串对象。
	- 在JDK1.7中，常量池是放在堆中的，如果堆中有相应的字符串，则执行intern方法，会在常量池存放相应字符串的引用，而不会再次创建一个对象。
3. 可能上面说的不是很清楚。那么就让我们结合下下面的题来进行理解吧。

### 0x03 题目解析
1. 说是有这样一段代码：
	```java
	public static void main(String[] args) {
	    String s = new String("1");
	    s.intern();
	    String s2 = "1";
	    System.out.println(s == s2);
	
	    String s3 = new String("1") + new String("1");
	    s3.intern();
	    String s4 = "11";
	    System.out.println(s3 == s4);
	}
	```
	- 代码的执行结果:
		- JDK1.6是输出 `false false`
		- JDK1.7是输出 `false true`
2. 为什么JDK1.6和JDK1.7的执行结果不一样呢？以及答案为什么是这样呢？下面来进行分析。
	1. JDK1.6
		1. 我们逐条进行分析。首先是`String s = new String("1");`,执行这条语句后，JVM会为我们创建2个对象。哪2个呢？一个是位于常量池中的`"1"`,另一个就是位于堆中的`String对象`。即用画图解释就是这样：
		![](http://studyimg.zyzling.top/19-1-3/19665118.jpg)
		2. 然后执行到了`s.intern()`方法。上面也说了，这个方法是先去常量池判断当前字符串是否在常量池中，如果在，则返回常量池中对当前字符串的引用。根据上图，我们清楚的知道s对象所对应的字符串已经在常量池中，所以执行`s.intern()`方法会返回常量池中对当前字符串的引用。但是很可惜，`s变量`并没有去接收他，也就是说`s变量`还是指向堆中`String对象`的地址，所以到这里，内存结构图还是和上图一样。即
		![](http://studyimg.zyzling.top/19-1-3/19665118.jpg)
		3. 继续往下走，就执行了`String s2="1"`。上面说了，用双引号声明的String对象会直接存放在常量池中。而常量池中已经有了一个一模一样的`"1"`，所以不会再次创建对象，而是将`s2变量`指向常量池中`"1"`.这时候内存结构图为：
		![](http://studyimg.zyzling.top/19-1-3/17512443.jpg)
		4. 很明显，`s变量`指向的是堆中的String对象，而`s2变量`指向的却是常量池中的对象。所以他们两个是不相等的。
		5. 继续走，就到了`String s3 = new String("1") + new String("1");`.这里会在常量池中生成`"1"`这个对象和在堆中生成`11`这个String对象。**注意，这时候`11`并不在常量池中**，这时候内存结构为：
		![](http://studyimg.zyzling.top/19-1-3/42259757.jpg)
		6. 往下面又执行了`s3.intern()`.这里会先去常量池中判断是否有`"11"`这个对象，很显然，这个时候常量池是没有的。所以会往常量池添加一个`"11"`对象。再返回该`"11"`在常量池中的地址。很可惜，这里的s3变量同样没有接收这个地址。这时候内存结构为：
		![](http://studyimg.zyzling.top/19-1-3/76263108.jpg)
		7. 再然后又执行了`String s4 = "11";`.因为`"11"`已经在常量池中了。所以这里s4是直接指向常量池中的`"11"`对象的。这时候的内存结构如下：
		![](http://studyimg.zyzling.top/19-1-3/97898209.jpg)
		8. 很明显。由于JDK1.6常量池不在堆中的原因，s3和s4也不相等。
	2. JDK1.7
		1. 和JDK1.6一样。`String s = new String("1");`也会创建2个对象。一个是常量池中的`"11"`,一个是堆中的`String对象`。但要注意的是，在JDK1.7中。常量池已经从方法区移到了堆中，由一个底层为HashSet的table来维护。此时内存结构如下：
		![](http://studyimg.zyzling.top/19-1-3/80870556.jpg)
		2. 执行`s.intern()`方法，同样，它会先去常量池中判断该字符串是否在，如果在，则返回在常量池中的当前字符串的引用。而又因为执行后，没有接收结果。所以内存结果还是和上图一样。即：
		![](http://studyimg.zyzling.top/19-1-3/80870556.jpg)
		3. 这时候又执行了`String s2 = "1";`。和JDK1.6一样。我就不在叙述了。直接上内存图。如下：
		![](http://studyimg.zyzling.top/19-1-3/57447983.jpg)
		4. 所以这里JDK1.7和JDK1.6是一样的结果，都是false。即都不相等。
		5. 继续走，`String s3 = new String("1") + new String("1");`这条语句执行后，同样和JDK1.6一样生成2个对象。图如下：
		![](http://studyimg.zyzling.top/19-1-3/54743457.jpg)
		6. 这时候执行`s3.intern();`同样会先去常量池判断，发现也没有。但是这里JDk1.7和JDK1.6处理是不一样的。JDK1.6会在常量池再次创建一个对象。而因为JDK1.7把常量池挪到堆中。所以它不会再次创建一个`"11"`对象,而是保存`"11"`在堆中的地址。此时，常量池中的地址和s3指向的地址相同。具体见图：
		![](http://studyimg.zyzling.top/19-1-3/67640945.jpg)
		7. `String s4 = "11";`执行后，因为在常量池已经存在。那么就会直接把常量池中的地址赋值给s4变量中。图为
		![](http://studyimg.zyzling.top/19-1-3/65250881.jpg)
		8. 因为常量池中存放的是s3的地址。所以s4实际上也是指向堆中`String对象`。所以他们俩是相等的。

### 0x03 结论
JDK1.6和JDK1.7对intern方法的唯一区别就是，在JDK1.6中，常量池是存放在方法区中的，而如果常量池没有当前字符串，就会去创建一个。而在JDK1.7中，常量池是在堆中。如果常量池没有当前字符串，堆中也没有，就会去创建，如果堆中有，是不会再次在常量池中创建，而是直接指向在堆中创建的对象。